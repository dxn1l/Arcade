package arcade.vista;

import arcade.persistencia.Partida;

import javax.swing.*;
import java.awt.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

public class PanelCaballo extends JPanel {

    private final int N;
    private final JButton[][] celdas;
    private final boolean[][] visitadas;
    private final JPanel panelTablero;
    private final JLabel mensajeLabel;
    private final JLabel contadorLabel;

    private int filaActual = -1, colActual = -1;
    private int movimientos = 0;

    public PanelCaballo(int N) {
        this.N = N;
        this.celdas = new JButton[N][N];
        this.visitadas = new boolean[N][N];

        setLayout(new BorderLayout());

        mensajeLabel = new JLabel("Selecciona una casilla para comenzar", SwingConstants.CENTER);
        mensajeLabel.setFont(new Font("SansSerif", Font.BOLD, 14));
        mensajeLabel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        add(mensajeLabel, BorderLayout.NORTH);

        panelTablero = new JPanel(new GridLayout(N, N));
        panelTablero.setPreferredSize(new Dimension(500, 500));
        panelTablero.setBorder(BorderFactory.createLineBorder(Color.BLACK, 2));
        inicializarTablero();
        add(panelTablero, BorderLayout.CENTER);

        JPanel panelInferior = new JPanel(new FlowLayout());

        JButton btnReiniciar = new JButton("Reiniciar recorrido");
        btnReiniciar.addActionListener(e -> reiniciarRecorrido());
        panelInferior.add(btnReiniciar);

        contadorLabel = new JLabel("Movimientos: 0");
        panelInferior.add(contadorLabel);
        add(panelInferior, BorderLayout.SOUTH);
    }

    private void inicializarTablero() {
        for (int fila = 0; fila < N; fila++) {
            for (int col = 0; col < N; col++) {
                JButton celda = new JButton();
                celda.setFont(new Font("SansSerif", Font.BOLD, 16));
                celda.setBackground((fila + col) % 2 == 0 ? Color.WHITE : new Color(200, 200, 200));
                final int f = fila;
                final int c = col;
                celda.addActionListener(e -> manejarClick(f, c));
                celdas[fila][col] = celda;
                panelTablero.add(celda);
            }
        }
    }

    private void manejarClick(int fila, int col) {
        if (filaActual == -1 && colActual == -1) {
            // Primer movimiento (inicio del recorrido)
            colocarCaballo(fila, col);
            mensajeLabel.setText("Selecciona el siguiente movimiento válido.");
        } else {
            if (esMovimientoValido(fila, col) && !visitadas[fila][col]) {
                colocarCaballo(fila, col);
                if (movimientos == N * N) {
                    mensajeLabel.setText("¡Recorrido completo!");
                    guardarPartida(true);
                    bloquearTablero();
                } else if (obtenerMovimientosValidos(fila, col).isEmpty()) {
                    mensajeLabel.setText("¡No hay más movimientos posibles!");
                    guardarPartida(false);
                    bloquearTablero();
                }
            } else {
                JOptionPane.showMessageDialog(this,
                        "Movimiento inválido. Solo podés moverte como un caballo.",
                        "Movimiento no permitido",
                        JOptionPane.WARNING_MESSAGE);
            }
        }
    }

    private void colocarCaballo(int fila, int col) {
        if (filaActual != -1 && colActual != -1) {
            celdas[filaActual][colActual].setText("" + movimientos);
        }

        filaActual = fila;
        colActual = col;
        movimientos++;
        contadorLabel.setText("Movimientos: " + movimientos);
        visitadas[fila][col] = true;
        celdas[fila][col].setText("♞");
        celdas[fila][col].setForeground(Color.BLUE);

        actualizarDisponibles();
    }

    private void actualizarDisponibles() {

        for (int f = 0; f < N; f++) {
            for (int c = 0; c < N; c++) {
                celdas[f][c].setEnabled(false);
            }
        }

        if (filaActual != -1 && colActual != -1) {
            for (int[] m : obtenerMovimientosValidos(filaActual, colActual)) {
                if (!visitadas[m[0]][m[1]]) {
                    celdas[m[0]][m[1]].setEnabled(true);
                }
            }
        }
    }

    private void reiniciarRecorrido() {

        String tipo = "RecorridoCaballo-" + N;
        String resumen = "Juego reiniciado por el usuario. " + movimientos + " movimientos registrados.";
        Partida reinicio = new Partida(tipo, resumen, java.time.LocalDateTime.now());
        reinicio.guardar();

        for (int fila = 0; fila < N; fila++) {
            for (int col = 0; col < N; col++) {
                celdas[fila][col].setText("");
                celdas[fila][col].setEnabled(true);
                visitadas[fila][col] = false;
            }
        }

        filaActual = -1;
        colActual = -1;
        movimientos = 0;
        contadorLabel.setText("Movimientos: 0");
        mensajeLabel.setText("Selecciona una casilla para comenzar");
        
    }


    private List<int[]> obtenerMovimientosValidos(int f, int c) {
        int[][] movs = {
                {-2, -1}, {-2, 1}, {-1, -2}, {-1, 2},
                {1, -2}, {1, 2}, {2, -1}, {2, 1}
        };
        List<int[]> validos = new ArrayList<>();
        for (int[] m : movs) {
            int nf = f + m[0];
            int nc = c + m[1];
            if (nf >= 0 && nf < N && nc >= 0 && nc < N && !visitadas[nf][nc]) {
                validos.add(new int[]{nf, nc});
            }
        }
        return validos;
    }

    private boolean esMovimientoValido(int fila, int col) {
        int df = Math.abs(fila - filaActual);
        int dc = Math.abs(col - colActual);
        return (df == 2 && dc == 1) || (df == 1 && dc == 2);
    }

    private void bloquearTablero() {
        for (int f = 0; f < N; f++) {
            for (int c = 0; c < N; c++) {
                celdas[f][c].setEnabled(false);
            }
        }
    }

    private void guardarPartida(boolean completado) {
        String resumen = completado
                ? "Recorrido completo con " + movimientos + " movimientos."
                : "Recorrido incompleto. " + movimientos + " movimientos realizados.";
        String tipo = "RecorridoCaballo-" + N;
        Partida partida = new Partida(tipo, resumen, LocalDateTime.now());
        partida.guardar();
    }
}
